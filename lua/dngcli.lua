--[[
 Copyright (C) 2010-2011 <reyalp (at) gmail dot com>

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
--]]
--[[
CLI commands for manipulating DNG images
]]
-- store info for DNG cli commands, global for easy script access
-- TODO move to own module
local m = {
	--selected = current selected dng, or nil
	list={},
}
m.get_index = function(to_find)
	for i,d in ipairs(m.list) do
		if d == to_find then
			return i
		end
	end
	return nil
end

--[[
make an output name from optional input name, replacing '.dng' with sfx if specified
if name is directory, default to dng name in that directory
if name not a string, default to dng name
]]
local function make_dst_name(d,name,sfx)
	if type(name) == 'string' then
		if lfs.attributes(name,'mode') == 'directory' then
			name = fsutil.joinpath(name,fsutil.basename(d.filename))
		else
			return name -- name specified and not a dir, just return it
		end
	else
		name = d.filename
	end
	if sfx then
		name = fsutil.remove_sfx(name,'.dng') .. sfx
	end
	return name
end

local function dngmod_single(d,args)
	if args.patch then
		if args.patch == true then
			args.patch = 0
		else
			args.patch = tonumber(args.patch)
		end
		local count = d.img:patch_pixels(args.patch)
		printf('patched %d pixels\n',count)
	end
end

-- find_files callback
local function dngmod_callback(self,opts)
	if #self.rpath == 0 and self.cur.st.mode == 'directory' then
		return true
	end
	if self.cur.name == '.' or self.cur.name == '..' then
		return true
	end
	local dargs = opts.dngmod_args
	local relpath
	local src=self.cur.full
	if #self.cur.path == 1 then
		relpath = self.cur.name
	else
		if #self.cur.path == 2 then
			relpath = self.cur.path[2]
		else
			relpath = fsutil.joinpath(unpack(self.cur.path,2))
		end
	end
	local dst
	if dargs.odir then
		dst=fsutil.joinpath_cam(dargs.odir,relpath)
	else
		dst=src
	end
	if self.cur.st.mode == 'directory' then
		return true
	end
	local dstdir = fsutil.dirname(dst)
	fsutil.mkdir_m(dstdir)
	if lfs.attributes(dst,'mode') == 'file' and not dargs.over then
		warnf("%s exists, skipping\n",dst)
		return true
	end
	printf("process %s->%s\n",src,dst)
	if dargs.pretend then
		return true
	end
	local d,err = dng.load(src)
	-- TODO warn and continue?
	if not d then 
		return false, err
	end
	dngmod_single(d,dargs)
	local fh, err = io.open(dst,'wb')
	if not fh then
		return false, err
	end
	local status, err = d._lb:fwrite(fh)
	fh:close()
	return status,err
end

m.init_cli = function()
	cli:add_commands{
	{
		names={'dngload'},
		help='load a dng file',
		arghelp="<file>",
		args=cli.argparser.create({
		}),
		help_detail=[[
 file: file to load
   only DNGs generated by CHDK or chdkptp are supported
]],
		func=function(self,args) 
			if not args[1] then
				return false,'expected filename'
			end
			local d,err = dng.load(args[1])
			if not d then 
				return false,err
			end
			m.selected = d
			table.insert(m.list,d)
			return true,'loaded '..d.filename
		end,
	},
	{
		names={'dngsave'},
		help='save a dng file',
		arghelp="[options] [file]",
		args=cli.argparser.create({
			over=false
		}),
		help_detail=[[
 file: file or directory to write to
   defaults to loaded name. if directory, appends original filename
 options:
   -over  overwrite existing files
]],
		func=function(self,args) 
			local filename
			local d = m.selected
			if not d then
				return false, 'no file selected'
			end
			local filename = args[1]

			if filename then
				if lfs.attributes(filename,'mode') == 'directory' then
					filename = fsutil.joinpath(filename,fsutil.basename(d.filename))
				end
			else
				filename = d.filename
			end
			local m = lfs.attributes(filename,'mode')
			if m == 'file' then
				if not args.over then
					return false, 'file exists, use -over to overwrite '..tostring(filename)
				end
			elseif m then -- TODO might want to allow
				return false, "can't overwrite non-file "..tostring(filename)
			end
			local fh,err = io.open(filename,'wb')
			if not fh then
				return false, err
			end
			local status, err = d._lb:fwrite(fh)
			fh:close()
			if status then
				return true, string.format('wrote %s',filename)
			end
			return false, err
		end,
	},
	{
		names={'dngunload'},
		help='unload dng file',
		func=function(self,args) 
			local d = m.selected
			if not d then
				return false, 'no file selected'
			end
			local di = m.get_index(d)
			table.remove(m.list,di)
			m.selected = nil
			return true, 'unloaded '..tostring(d.filename)
		end,
	},
	{
		names={'dnginfo'},
		help='display information about a dng',
		arghelp="[options]",
		args=cli.argparser.create({
			s=false,
			ifd=false,
			h=false,
			r=false,
			v=false,
		}),
		help_detail=[[
 options:
   -s   summary info, default if no other options given
   -h   tiff header
   -ifd[=<ifd>]
   	   raw, exif, main, or 0, 0.0 etc. default 0
   -r   recurse into sub-ifds
   -v   display ifd values, except image data
]],
		func=function(self,args) 
			local d = m.selected
			if not d then
				return false, 'no file selected'
			end
			if not args.h and not args.ifd then
				args.s = true
			end
			printf("%s:\n",d.filename)
			if args.s then
				d:print_summary()
			end
			if args.h then
				d:print_header()
			end
			if args.ifd then
				local ifd
				if args.ifd == true then
					ifd = d.main_ifd
				elseif args.ifd == 'raw' then
					ifd = d.raw_ifd
				elseif args.ifd == 'main' then
					ifd = d.main_ifd
				elseif args.ifd == 'exif' then
					ifd = d.exif_ifd
				else
					local path={}
					util.string_split(args.ifd,'.',{
						plain=true,
						func=function(v)
							local n=tonumber(v)
							if n then
								table.insert(path,n)
							else
								table.insert(path,v)
							end
						end
					})
					ifd = d:get_ifd(path)
				end
				if not ifd then
					return false, 'could not find ifd ',tostring(args.ifd)
				end
				d:print_ifd(ifd,{recurse=args.r})
			end
			return true
		end,
	},
	{
		names={'dnglist'},
		help='list loaded dng files',
		func=function(self,args) 
			local r=''
			for i, d in ipairs(m.list) do
				if d == m.selected then
					r = r .. '*'
				else
					r = r .. ' '
				end
				r = r .. string.format('%-3d: %s\n',i,d.filename)
			end
			return true, r
		end,
	},
	{
		names={'dngsel'},
		help='select dng',
		arghelp="<number>",
		args=cli.argparser.create({
			ifds=false,
		}),
		help_detail=[[
 number:
   dng number from dnglist to select
]],
		func=function(self,args) 
			local n = tonumber(args[1])
			if m.list[n] then
				m.selected = m.list[n]
				return true, string.format('selected %d: %s',n,m.selected.filename)
			end
			return false, 'invalid selection'
		end,
	},
	{
		names={'dngmod'},
		help='modify dng',
		arghelp="[options] [files]",
		args=cli.argparser.create({
			patch=false,
			fmatch=false,
			rmatch=false,
			maxdepth=100,
			pretend=false,
			odir=false,
			over=false,
		}),
		help_detail=[[
 options:
   -patch[=number]   patch bad pixels
 file selection
   -fmatch=<pattern> only file with path/name matching <pattern>
   -rmatch=<pattern> only recurse into directories with path/name matching <pattern>
   -maxdepth=n       only recurse into N levels of directory
   -pretend          print actions instead of doing them
   -over             overwrite existing
]],
		func=function(self,args) 
			if #args == 0 then
				local d = m.selected
				if d then
					dngmod_single(d,args)
					return true
				else
					return false, 'no file selected'
				end
			end
			local opts={
				dirsfirst=true,
				fmatch=args.fmatch,
				rmatch=args.rmatch,
				pretend=args.pretend,
				maxdepth=tonumber(args.maxdepth),
				dngmod_args=args,
			}
			return fsutil.find_files({unpack(args)},opts,dngmod_callback)
		end,
	},
	{
		names={'dngdump'},
		help='extract data from dng',
		arghelp="[options]",
		args=cli.argparser.create({
			thm=false,
			raw=false,
			rfmt=false,
			tfmt=false,
		}),
		-- TODO filename handling
		help_detail=[[
 options:
   -thm[=name]   extract thumbnail to name, default dngname_thm.(rgb|ppm)
   -raw[=name]   extract raw data to name, default dngname.(raw|pgm)
   -rfmt=fmt raw format (default: unmodified from DNG)
     format is <bpp>[l|b|pgm], e.g. 8pgm or 12l
	 pgm is only valid with 8 (TODO add 16 bit support)
	 byte order defaults to little
   -tfmt=fmt thumb format (default, unmodified rgb)
     ppm   8 bit rgb ppm
    
]],
		func=function(self,args) 
			local d = m.selected
			if not d then
				return false, 'no file selected'
			end
			if args.thm then
				if not args.tfmt then
					d.main_ifd:write_image_data(make_dst_name(d,args.thm,'_thm.rgb'))
				elseif args.tfmt == 'ppm' then
					-- TODO should check that it's actually an RGB8 thumb
					local fh, err = io.open(make_dst_name(d,args.thm,'.ppm'),'wb')
					if not fh then
						return false,err
					end
					fh:write(string.format('P6\n%d\n%d\n%d\n',
						d.main_ifd.byname.ImageWidth:getel(),
						d.main_ifd.byname.ImageLength:getel(),255))
					d.main_ifd:write_image_data(fh)
					fh:close()
				else
					return false, 'invalid thumbnail format requested: '..tostring(args.tfmt)
				end
			end
			if args.raw then
				if not args.rfmt then
					d.raw_ifd:write_image_data(make_dst_name(d,args.raw,'.raw'))
				else
					local bpp,fmt=string.match(args.rfmt,'(%d+)(%a*)')
					bpp = tonumber(bpp)
					if fmt == 'pgm' then
						return d:dump_image(make_dst_name(d,args.raw,'.pgm'),{bpp=bpp,pgm=true})
					end
					if fmt == '' then
						fmt = 'l'
					end
					return d:dump_image(make_dst_name(d,args.raw,'.raw'),{bpp=bpp,endian=({l='little',b='big'})[fmt]})
				end
			end
			return true
		end,
	},
}
end

return m
